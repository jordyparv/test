Write a detailed unit test for a function in a Node.js application that interacts with a database using an ORM. Use Jest as the testing framework.

async create(createSwitchDirectiveDto: CreateSwitchDirectiveDto) {
  return await this.DirectiveGroupEntityRepository.manager.transaction(
    async (transactionalEntityManager) => {
      // Check if group already exists
      const existingGroup = await transactionalEntityManager
        .createQueryBuilder()
        .select('g.GROUP_ID')
        .from(DirectiveGroupEntity, 'g')
        .where('g.GROUP_NAME = :groupName', {
          groupName: createSwitchDirectiveDto.group_name,
        })
        .getOne();

      if (existingGroup) {
        throw new HttpException(
          {
            message: 'Group name already exists',
            status: HttpStatus.BAD_REQUEST,
          },
          HttpStatus.BAD_REQUEST,
        );
      }

      // Get next group ID
      const groupIdQuery = await transactionalEntityManager.query(
        'SELECT DIRECTIVE_GROUP_SEQ.NEXTVAL FROM dual',
      );
      const groupId = groupIdQuery[0]?.NEXTVAL;

      // Insert the group
      await transactionalEntityManager
        .createQueryBuilder()
        .insert()
        .into(DirectiveGroupEntity)
        .values({
          GROUP_NAME: createSwitchDirectiveDto.group_name,
          GROUP_ID: groupId,
          META_CREATED_BY: createSwitchDirectiveDto.created_by,
          META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
          META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
        })
        .execute();

      // Get next mapping ID
      const mappingIdQuery = await transactionalEntityManager.query(
        'SELECT DIRECTIVE_USER_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
      );
      const mappingId = mappingIdQuery[0]?.NEXTVAL;

      // Insert user group mapping
      await transactionalEntityManager
        .createQueryBuilder()
        .insert()
        .into(DirectiveUserGroupMappingEntity)
        .values({
          MAPPING_ID: mappingId,
          USER_ID: createSwitchDirectiveDto.assigned_mgr,
          GROUP_ID: groupId,
          META_CREATED_BY: createSwitchDirectiveDto.created_by,
          META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
          META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          ASSIGNED_TEAM: createSwitchDirectiveDto.teams
            ? createSwitchDirectiveDto.teams.join(',')
            : '',
        })
        .execute();

      // Insert elements if provided
      if (createSwitchDirectiveDto.elements?.length) {
        const elementsToInsert = await Promise.all(
          createSwitchDirectiveDto.elements.map(async (ELEMENT_ID) => {
            const elementMappingIdQuery = await transactionalEntityManager.query(
              'SELECT DIRECTIVE_ELEMENT_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
            );
            const elementMappingId = elementMappingIdQuery[0]?.NEXTVAL;

            return {
              ELEMENT_MAPPING_ID: elementMappingId,
              GROUP_ID: groupId,
              ELEMENT_ID,
              META_CREATED_BY: createSwitchDirectiveDto.created_by,
              META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
              META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
              META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            };
          }),
        );

        await transactionalEntityManager
          .createQueryBuilder()
          .insert()
          .into(DirectiveElementGroupMappingEntity)
          .values(elementsToInsert)
          .execute();
      }

      return {
        message: 'Switch directive saved successfully',
        status: HttpStatus.CREATED,
      };
    },
  );
}









import { Test, TestingModule } from '@nestjs/testing';
import { SwitchDirectiveService } from './switch-directive.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { DirectiveGroupEntity } from './entities/DirectiveGroupEntity';
import { DirectiveUserGroupMappingEntity } from './entities/DirectiveUserGroupMappingEntity';
import { DirectiveElementGroupMappingEntity } from './entities/DirectiveElementGroupMappingEntity';
import { HttpException, HttpStatus } from '@nestjs/common';
import { CreateSwitchDirectiveDto } from './dto/create-switch-directive.dto';

jest.mock('@nestjs/typeorm'); // Mock the repository methods

describe('SwitchDirectiveService', () => {
  let service: SwitchDirectiveService;
  let directiveGroupRepo;
  let directiveUserGroupMappingRepo;
  let directiveElementGroupMappingRepo;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SwitchDirectiveService,
        {
          provide: getRepositoryToken(DirectiveGroupEntity),
          useValue: {
            manager: {
              transaction: jest.fn(),
              createQueryBuilder: jest.fn(),
              query: jest.fn(),
            },
          },
        },
        {
          provide: getRepositoryToken(DirectiveUserGroupMappingEntity),
          useValue: {
            manager: {
              createQueryBuilder: jest.fn(),
              query: jest.fn(),
            },
          },
        },
        {
          provide: getRepositoryToken(DirectiveElementGroupMappingEntity),
          useValue: {
            manager: {
              createQueryBuilder: jest.fn(),
              query: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<SwitchDirectiveService>(SwitchDirectiveService);
    directiveGroupRepo = module.get(getRepositoryToken(DirectiveGroupEntity));
    directiveUserGroupMappingRepo = module.get(getRepositoryToken(DirectiveUserGroupMappingEntity));
    directiveElementGroupMappingRepo = module.get(getRepositoryToken(DirectiveElementGroupMappingEntity));
  });

  it('should successfully create a switch directive', async () => {
    const mockCreateSwitchDirectiveDto: CreateSwitchDirectiveDto = {
      group_name: 'Test Group',
      assigned_mgr: 1,
      created_by: 1,
      teams: ['Team A'],
      elements: [101, 102],
    };

    // Mock responses for all DB queries
    const mockTransaction = jest.fn().mockResolvedValue({
      message: 'Switch directive saved successfully',
      status: HttpStatus.CREATED,
    });

    directiveGroupRepo.manager.transaction.mockImplementation(mockTransaction);

    // Mock createQueryBuilder and query methods
    directiveGroupRepo.manager.createQueryBuilder.mockReturnValue({
      select: jest.fn().mockReturnThis(),
      from: jest.fn().mockReturnThis(),
      where: jest.fn().mockReturnThis(),
      getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group
      insert: jest.fn().mockReturnThis(),
      into: jest.fn().mockReturnThis(),
      values: jest.fn().mockReturnThis(),
      execute: jest.fn().mockResolvedValue({ affected: 1 }),
    });

    directiveUserGroupMappingRepo.manager.createQueryBuilder.mockReturnValue({
      insert: jest.fn().mockReturnThis(),
      into: jest.fn().mockReturnThis(),
      values: jest.fn().mockReturnThis(),
      execute: jest.fn().mockResolvedValue({ affected: 1 }),
    });

    directiveElementGroupMappingRepo.manager.createQueryBuilder.mockReturnValue({
      insert: jest.fn().mockReturnThis(),
      into: jest.fn().mockReturnThis(),
      values: jest.fn().mockReturnThis(),
      execute: jest.fn().mockResolvedValue({ affected: 1 }),
    });

    // Mock the query method for sequences
    directiveGroupRepo.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]);
    directiveGroupRepo.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]);
    directiveGroupRepo.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]);

    const result = await service.create(mockCreateSwitchDirectiveDto);

    // Test assertions
    expect(result.message).toBe('Switch directive saved successfully');
    expect(result.status).toBe(HttpStatus.CREATED);
    expect(directiveGroupRepo.manager.transaction).toHaveBeenCalled();
    expect(directiveGroupRepo.manager.createQueryBuilder).toHaveBeenCalled();
    expect(directiveGroupRepo.manager.query).toHaveBeenCalledTimes(3); // Called three times for groupId, mappingId, and elementMappingId queries
  });

  it('should throw error if group name already exists', async () => {
    const mockCreateSwitchDirectiveDto: CreateSwitchDirectiveDto = {
      group_name: 'Existing Group',
      assigned_mgr: 1,
      created_by: 1,
      teams: ['Team A'],
      elements: [101, 102],
    };

    // Mock existing group to return a group
    directiveGroupRepo.manager.createQueryBuilder.mockReturnValue({
      select: jest.fn().mockReturnThis(),
      from: jest.fn().mockReturnThis(),
      where: jest.fn().mockReturnThis(),
      getOne: jest.fn().mockResolvedValue({ GROUP_ID: 1 }), // Simulate existing group
    });

    try {
      await service.create(mockCreateSwitchDirectiveDto);
    } catch (e) {
      expect(e).toBeInstanceOf(HttpException);
      expect(e.response.message).toBe('Group name already exists');
      expect(e.response.status).toBe(HttpStatus.BAD_REQUEST);
    }
  });
});














// Create a mock of the queryRunner, with all necessary methods
const mockQueryRunner = {
  startTransaction: jest.fn(),
  commitTransaction: jest.fn(),
  rollbackTransaction: jest.fn(),
  release: jest.fn(),
  manager: {
    createQueryBuilder: jest.fn().mockReturnValue({
      getOne: jest.fn().mockResolvedValue(null), // Mock getOne to simulate no existing group
      insert: jest.fn().mockReturnThis(), // Allow method chaining for insert
      execute: jest.fn().mockResolvedValue({ affected: 1, generatedMaps: [] }) // Simulate successful execution
    }),
    query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]) // Simulate query returning nextval for sequence
  }
};

// Mock the connection's createQueryRunner method
jest.spyOn(directiveGroupRepo.manager.connection, 'createQueryRunner').mockReturnValue(mockQueryRunner);

// Mock the manager object itself
jest.spyOn(directiveGroupRepo, 'manager', 'get').mockReturnValue(mockQueryRunner.manager);



import { Test, TestingModule } from '@nestjs/testing';
import { SwitchDirectiveService } from './switch-directive.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { DirectiveGroupEntity } from './entities/DirectiveGroupEntity';
import { DirectiveUserGroupMappingEntity } from './entities/DirectiveUserGroupMappingEntity';
import { DirectiveElementGroupMappingEntity } from './entities/DirectiveElementGroupMappingEntity';
import { HttpException, HttpStatus } from '@nestjs/common';
import { createMock } from '@golevelup/ts-jest';

let service: SwitchDirectiveService;
let directiveGroupRepo: Repository<DirectiveGroupEntity>;
let directiveUserGroupMappingRepo: Repository<DirectiveUserGroupMappingEntity>;
let queryRunner: any;
let mockCreateSwitchDirectiveDto: any;

beforeEach(async () => {
  // Create the mock DTO
  mockCreateSwitchDirectiveDto = {
    group_name: 'Test Group',
    created_by: 'admin',
    assigned_mgr: 'manager1',
    teams: ['team1', 'team2'],
    elements: [101, 102, 103],
  };

  // Mock the queryRunner and repository methods
  queryRunner = {
    startTransaction: jest.fn(),
    commitTransaction: jest.fn(),
    rollbackTransaction: jest.fn(),
    release: jest.fn(),
    manager: {
      createQueryBuilder: jest.fn().mockReturnValue({
        getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group found
        insert: jest.fn().mockReturnThis(), // Allow chaining
        execute: jest.fn().mockResolvedValue({ affected: 1, generatedMaps: [] }), // Simulate successful insert with affected rows
      }),
      query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]), // Mock sequence value for group ID
    },
  };

  const module: TestingModule = await Test.createTestingModule({
    providers: [
      SwitchDirectiveService,
      {
        provide: getRepositoryToken(DirectiveGroupEntity),
        useValue: createMock<Repository<DirectiveGroupEntity>>({
          manager: {
            createQueryBuilder: jest.fn().mockReturnValue({
              getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group
            }),
            query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]), // Mock sequence query for group ID
          },
        }),
      },
      {
        provide: getRepositoryToken(DirectiveUserGroupMappingEntity),
        useValue: createMock<Repository<DirectiveUserGroupMappingEntity>>(),
      },
      {
        provide: getRepositoryToken(DirectiveElementGroupMappingEntity),
        useValue: createMock<Repository<DirectiveElementGroupMappingEntity>>(),
      },
    ],
  }).compile();

  service = module.get<SwitchDirectiveService>(SwitchDirectiveService);
  directiveGroupRepo = module.get<Repository<DirectiveGroupEntity>>(getRepositoryToken(DirectiveGroupEntity));
  directiveUserGroupMappingRepo = module.get<Repository<DirectiveUserGroupMappingEntity>>(getRepositoryToken(DirectiveUserGroupMappingEntity));

  // Spying on the methods of queryRunner
  jest.spyOn(queryRunner, 'startTransaction');
  jest.spyOn(queryRunner, 'commitTransaction');
  jest.spyOn(queryRunner, 'rollbackTransaction');
  jest.spyOn(queryRunner, 'release');
  jest.spyOn(queryRunner.manager, 'createQueryBuilder').mockReturnValue({
    getOne: jest.fn().mockResolvedValue(null), // No existing group
    insert: jest.fn().mockReturnThis(), // Chaining insert
    execute: jest.fn().mockResolvedValue({ affected: 1, generatedMaps: [] }), // Simulate successful insert
  });
  jest.spyOn(queryRunner.manager, 'query').mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Mock sequence value
});

it('should successfully create a switch directive', async () => {
  // Mock query results for group, mapping, and element IDs
  queryRunner.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Group ID
  queryRunner.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Mapping ID
  queryRunner.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Element Mapping ID

  // Mock successful insert operation
  directiveGroupRepo.manager.createQueryBuilder().execute.mockResolvedValue({ affected: 1, generatedMaps: [] });

  const result = await service.create(mockCreateSwitchDirectiveDto);

  // Verify that the method returned the expected response
  expect(result.message).toBe('Switch directive saved successfully');
  expect(result.status).toBe(HttpStatus.CREATED);

  // Verify that the transaction methods were called
  expect(queryRunner.startTransaction).toHaveBeenCalled();
  expect(queryRunner.commitTransaction).toHaveBeenCalled();
  expect(queryRunner.release).toHaveBeenCalled();

  // Verify that createQueryBuilder was called correctly
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledTimes(3); // Three calls: one for group, one for mapping, one for elements
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledWith('INSERT INTO DirectiveGroupEntity');
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledWith('INSERT INTO DirectiveUserGroupMappingEntity');
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledWith('INSERT INTO DirectiveElementGroupMappingEntity');
});

it('should throw an error when group name already exists', async () => {
  // Mocking an existing group
  queryRunner.manager.createQueryBuilder().getOne.mockResolvedValue({ GROUP_ID: 1 });

  try {
    await service.create(mockCreateSwitchDirectiveDto);
  } catch (error) {
    expect(error).toBeInstanceOf(HttpException);
    expect(error.response.message).toBe('Group name already exists');
    expect(error.response.status).toBe(HttpStatus.BAD_REQUEST);
  }

  // Verify that rollback is called when an error occurs
  expect(queryRunner.rollbackTransaction).toHaveBeenCalled();
});
















useValue: createMock<Repository<DirectiveGroupEntity>>({
          manager: {
            createQueryBuilder: jest.fn().mockReturnValue({
              getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group
              // You can mock other query builder methods as needed
            }),
            query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]), // Mock sequence query
            connection: {
              createQueryRunner: jest.fn().mockReturnValue(queryRunner), // Mocking queryRunner
            },
          },
        }),


beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SwitchDirectiveService,
        {
          provide: getRepositoryToken(DirectiveUserGroupMappingEntity),
          useValue: createMock<Repository<DirectiveUserGroupMappingEntity>>(),
        },
        {
          provide: getRepositoryToken(DirectiveGroupEntity),
          useValue: createMock<Repository<DirectiveGroupEntity>>(),
        },
        {
          provide: getRepositoryToken(DirectiveElementGroupMappingEntity),
          useValue:
            createMock<Repository<DirectiveElementGroupMappingEntity>>(),
        },
        {
          provide: getRepositoryToken(SecContactEntity),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(SwitchElementEntity),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(SecUsersEntity),
          useClass: Repository,
        },
      ],
    }).compile();

    service = module.get<SwitchDirectiveService>(SwitchDirectiveService);
    directiveUserGroupMappingRepo = module.get<
      Repository<DirectiveUserGroupMappingEntity>
    >(getRepositoryToken(DirectiveUserGroupMappingEntity));
    directiveGroupRepo = module.get<Repository<DirectiveGroupEntity>>(
      getRepositoryToken(DirectiveGroupEntity),
    );
    directiveElementGroupMappingRepo = module.get<
      Repository<DirectiveElementGroupMappingEntity>
    >(getRepositoryToken(DirectiveElementGroupMappingEntity));
    secContactRepo = module.get<Repository<SecContactEntity>>(
      getRepositoryToken(SecContactEntity),
    );
    switchElementRepo = module.get<Repository<SwitchElementEntity>>(
      getRepositoryToken(SwitchElementEntity),
    );
    secUsersRepo = module.get<Repository<SecUsersEntity>>(
      getRepositoryToken(SecUsersEntity),
    );
    queryRunner = {
      startTransaction: jest.fn(),
      commitTransaction: jest.fn(),
      rollbackTransaction: jest.fn(),
      release: jest.fn(),
      manager: {
        createQueryBuilder: jest.fn(),
        query: jest.fn(),
        connection: {
          createQueryRunner: jest.fn().mockReturnValue(queryRunner),
        },
      }
    }
  });




async create(createSwitchDirectiveDto: CreateSwitchDirectiveDto) {
    const queryRunner =
      this.DirectiveGroupEntityRepository.manager.connection.createQueryRunner();
    await queryRunner.startTransaction();

    try {
      const existingGroup = await queryRunner.manager
        .createQueryBuilder()
        .select('g.GROUP_ID')
        .from(DirectiveGroupEntity, 'g')
        .where('g.GROUP_NAME = :groupName', {
          groupName: createSwitchDirectiveDto.group_name,
        })
        .getOne();

      if (existingGroup) {
        throw new HttpException(
          {
            message: 'Group name already exists',
            status: HttpStatus.BAD_REQUEST,
          },
          HttpStatus.BAD_REQUEST,
        );
      }

      const groupIdQuery = await queryRunner.manager.query(
        'SELECT DIRECTIVE_GROUP_SEQ.NEXTVAL FROM dual',
      );
      const groupId = groupIdQuery[0]?.NEXTVAL;

      await queryRunner.manager
        .createQueryBuilder()
        .insert()
        .into(DirectiveGroupEntity)
        .values({
          GROUP_NAME: createSwitchDirectiveDto.group_name,
          GROUP_ID: groupId,
          META_CREATED_BY: createSwitchDirectiveDto.created_by,
          META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
          META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
        })
        .execute();

      const mappingIdQuery = await queryRunner.manager.query(
        'SELECT DIRECTIVE_USER_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
      );
      const mappingId = mappingIdQuery[0]?.NEXTVAL;

      await queryRunner.manager
        .createQueryBuilder()
        .insert()
        .into(DirectiveUserGroupMappingEntity)
        .values({
          MAPPING_ID: mappingId,
          USER_ID: createSwitchDirectiveDto.assigned_mgr,
          GROUP_ID: groupId,
          META_CREATED_BY: createSwitchDirectiveDto.created_by,
          META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
          META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          ASSIGNED_TEAM: createSwitchDirectiveDto.teams
            ? createSwitchDirectiveDto.teams.join(',')
            : '',
        })
        .execute();

      if (createSwitchDirectiveDto.elements?.length) {
        const elementsToInsert = await Promise.all(
          createSwitchDirectiveDto.elements.map(async (ELEMENT_ID) => {
            const elementMappingIdQuery = await queryRunner.manager.query(
              'SELECT DIRECTIVE_ELEMENT_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
            );
            const elementMappingId = elementMappingIdQuery[0]?.NEXTVAL;

            return {
              ELEMENT_MAPPING_ID: elementMappingId,
              GROUP_ID: groupId,
              ELEMENT_ID,
              META_CREATED_BY: createSwitchDirectiveDto.created_by,
              META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
              META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
              META_LAST_UPDATED_DATE: () =>
                'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            };
          }),
        );

        await queryRunner.manager
          .createQueryBuilder()
          .insert()
          .into(DirectiveElementGroupMappingEntity)
          .values(elementsToInsert)
          .execute();
      }

      await queryRunner.commitTransaction();

      return {
        message: 'Switch directive saved successfully',
        status: HttpStatus.CREATED,
      };
    } catch (error) {
      await queryRunner.rollbackTransaction();
      logger.error(`Unable to add switch directive => ${error.message}`);

      throw new HttpException(
        { message: error.message },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    } finally {
      await queryRunner.release();
    }
  }
