describe("getSwitchDetailForTypeAhead", () => {
    let req;
    let res;
    let mockSwitchRepo;
    let mockLogger;

    beforeEach(() => {
        mockSwitchRepo = {
            getSwitchDetailForTypeAhead: jest.fn(),
        };
        
        mockLogger = {
            error: jest.fn(),
        };

        req = { query: {} };
        res = { 
            status: jest.fn().mockReturnThis(), 
            json: jest.fn() 
        };
    });

    it("should return BAD_REQUEST if no filters are provided", async () => {
        await service.getSwitchDetailForTypeAhead(req, res);
        expect(res.status).toHaveBeenCalledWith(HttpStatus.BAD_REQUEST);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.BAD_REQUEST,
            message: "Please provide the filters.",
        });
    });

    it("should return OK with empty data if no relevant query parameters are provided", async () => {
        req.query = {
            some_other_param: 'value',
        };
        await service.getSwitchDetailForTypeAhead(req, res);
        expect(res.status).toHaveBeenCalledWith(HttpStatus.OK);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.OK,
            data: [],
        });
    });

    it("should fetch data based on main_switch_name filter", async () => {
        req.query = { main_switch_name: 'Main Switch' };
        const mockData = [{ id: 1, name: 'Main Switch' }];

        jest.spyOn(mockSwitchRepo, "getSwitchDetailForTypeAhead").mockResolvedValue(mockData);

        await service.getSwitchDetailForTypeAhead(req, res);
        
        expect(mockSwitchRepo.getSwitchDetailForTypeAhead).toHaveBeenCalledWith({
            key: "main_switch",
            value: expect.stringContaining('Main Switch'),
        });
        expect(res.status).toHaveBeenCalledWith(HttpStatus.OK);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.OK,
            message: "Data fetched successfully!",
            data: mockData,
        });
    });

    it("should fetch data based on remedy_switch filter", async () => {
        req.query = { remedy_switch: 'Remedy Switch' };
        const mockData = [{ id: 2, name: 'Remedy Switch' }];

        jest.spyOn(mockSwitchRepo, "getSwitchDetailForTypeAhead").mockResolvedValue(mockData);

        await service.getSwitchDetailForTypeAhead(req, res);
        
        expect(mockSwitchRepo.getSwitchDetailForTypeAhead).toHaveBeenCalledWith({
            key: "remedy_switch",
            value: expect.stringContaining('Remedy Switch'),
        });
        expect(res.status).toHaveBeenCalledWith(HttpStatus.OK);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.OK,
            message: "Data fetched successfully!",
            data: mockData,
        });
    });

    it("should fetch data based on remedy_callout filter", async () => {
        req.query = { remedy_callout: 'Callout' };
        const mockData = [{ id: 3, name: 'Callout' }];

        jest.spyOn(mockSwitchRepo, "getSwitchDetailForTypeAhead").mockResolvedValue(mockData);

        await service.getSwitchDetailForTypeAhead(req, res);
        
        expect(mockSwitchRepo.getSwitchDetailForTypeAhead).toHaveBeenCalledWith({
            key: "remedy_callout",
            value: expect.stringContaining('Callout'),
        });
        expect(res.status).toHaveBeenCalledWith(HttpStatus.OK);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.OK,
            message: "Data fetched successfully!",
            data: mockData,
        });
    });

    it("should return OK with empty data if no data is found", async () => {
        req.query = { main_switch_name: 'Nonexistent Switch' };
        jest.spyOn(mockSwitchRepo, "getSwitchDetailForTypeAhead").mockResolvedValue([]);

        await service.getSwitchDetailForTypeAhead(req, res);
        
        expect(res.status).toHaveBeenCalledWith(HttpStatus.OK);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.OK,
            message: "Data fetched successfully!",
            data: [],
        });
    });

    it("should log errors and return INTERNAL_SERVER_ERROR", async () => {
        req.query = { main_switch_name: 'Error Switch' };
        jest.spyOn(mockSwitchRepo, "getSwitchDetailForTypeAhead").mockImplementation(() => {
            throw new Error("Database error");
        });

        await service.getSwitchDetailForTypeAhead(req, res);
        
        expect(mockLogger.error).toHaveBeenCalledWith("Database error");
        expect(res.status).toHaveBeenCalledWith(HttpStatus.INTERNAL_SERVER_ERROR);
        expect(res.json).toHaveBeenCalledWith({
            statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
            message: "Something went wrong! try again later.",
        });
    });
});
