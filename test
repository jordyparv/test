async getSwitchDirective() {
  // Step 1: Fetch the raw data
  const rawData = await this.DirectiveGroupEntityRepository.createQueryBuilder('gr')
    .select([
      `gr.GROUP_NAME AS "group_name"`,
      `gr.META_CREATED_BY AS "created_by"`,
      `TO_CHAR(TRUNC(gr.META_CREATED_DATE), 'YYYY-MM-DD') AS "created_on"`,
      `gr.GROUP_ID AS "group_id"`,
      `ugm.MAPPING_ID AS "mapping_id"`,
      `ugm.ASSIGNED_TEAM AS "assigned_team"`,
      `sc.LASTNAME || ', ' || sc.FIRSTNAME AS "assigned_to"`,
      `sele.VENDOR AS "vendor"`,
      `sele.ELEMENT_DIVISION AS "elements_division"`,
      `sele.ELEMENT_DEPT AS "element_dept"`,
      `sele.ELEMENT_ID AS "element_id"`,
    ])
    .innerJoin(DirectiveUserGroupMappingEntity, 'ugm', 'ugm.GROUP_ID = gr.GROUP_ID')
    .innerJoin(DirectiveElementGroupMappingEntity, 'egm', 'egm.GROUP_ID = gr.GROUP_ID')
    .innerJoin(SwitchElementEntity, 'sele', 'sele.ELEMENT_ID = egm.ELEMENT_ID')
    .innerJoin(SecContactEntity, 'sc', 'sc.LOGIN_ID = ugm.USER_ID')
    .getRawMany();

  // Step 2: Process the raw data into the desired structure
  const groupedData = [];

  for (const row of rawData) {
    const teams = await this.SecContactEntityRepository
      .createQueryBuilder()
      .select([
        `TRIM(LASTNAME) || ', ' || TRIM(FIRSTNAME) AS "switchtech_name"`,
        `role AS "role"`,
        `login_id AS "login_id"`,
      ])
      .whereInIds(row?.assigned_team?.split(','))
      .getRawMany();

    const { element_id, elements_division, element_dept, group_id, vendor, ...rest } = row;

    // Find the existing group or create a new one if it doesn't exist
    let group = groupedData.find((g) => g.group_id === group_id);
    if (!group) {
      group = {
        elements_division,
        vendor,
        ...rest,
        teams,
        elements: [], // Initialize the elements array
      };
      groupedData.push(group);
    }

    // Add the element information to the group's elements array
    group.elements.push({
      element_id,
      element_name: elements_division,
      vendor,
      sub_element_name: element_dept,
    });

    // Update element_dept count
    group.element_dept = `${group.elements.length} Dept`;
  }

  // Step 3: Return the grouped data
  return groupedData;
}
