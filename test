    // Mock the query runner that is used for database operations in the service
    queryRunner = {
      startTransaction: jest.fn(),
      commitTransaction: jest.fn(),
      rollbackTransaction: jest.fn(),
      release: jest.fn(),
      manager: {
        createQueryBuilder: jest.fn(),
        query: jest.fn(),
      },
    };

    jest.spyOn(directiveGroupRepo.manager.connection, 'createQueryRunner').mockReturnValue(queryRunner);


 it('should correctly create a switch directive and handle transactions', async () => {
    // Arrange
    const createSwitchDirectiveDto: CreateSwitchDirectiveDto = {
      group_name: 'Group 1',
      assigned_mgr: 'manager1',
      created_by: 'Admin',
      teams: ['user1', 'user2'],
      elements: [1, 2],
    };

    const existingGroup = null; // Simulate no existing group name
    const groupId = 1; // Simulate generated group ID
    const mappingId = 1; // Simulate generated mapping ID
    const elementMappingId = 1; // Simulate generated element mapping ID

    // Spy on the repository methods and simulate database behavior
    const createQueryBuilderSpy = jest.spyOn(queryRunner.manager, 'createQueryBuilder');
    const querySpy = jest.spyOn(queryRunner.manager, 'query');

    // Simulating sequence results (for groupId, mappingId, elementMappingId)
    querySpy.mockResolvedValueOnce([{ NEXTVAL: groupId }]) // Simulating getting group ID from sequence
      .mockResolvedValueOnce([{ NEXTVAL: mappingId }]) // Simulating getting mapping ID from sequence
      .mockResolvedValueOnce([{ NEXTVAL: elementMappingId }]); // Simulating getting element mapping ID from sequence

    // Simulating the behavior of `createQueryBuilder` for the SELECT query to check for an existing group
    createQueryBuilderSpy
      .mockReturnValueOnce({
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(existingGroup),
      })
      .mockReturnValueOnce({
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        execute: jest.fn(),
      }) // Simulate insert for group
      .mockReturnValueOnce({
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        execute: jest.fn(),
      }) // Simulate insert for mapping
      .mockReturnValueOnce({
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        execute: jest.fn(),
      }); // Simulate insert for elements

    // Act
    const result = await service.create(createSwitchDirectiveDto);

    // Assert
    expect(result).toEqual({
      message: 'Switch directive saved successfully',
      status: HttpStatus.CREATED,
    });

    // Ensure the appropriate query methods are called
    expect(queryRunner.startTransaction).toHaveBeenCalled();
    expect(queryRunner.commitTransaction).toHaveBeenCalled();
    expect(queryRunner.release).toHaveBeenCalled();
    expect(createQueryBuilderSpy).toHaveBeenCalledTimes(4); // Four queries are expected (select for group, inserts for group, mapping, and elements)
  });

  it('should throw error if group name already exists', async () => {
    // Arrange
    const createSwitchDirectiveDto: CreateSwitchDirectiveDto = {
      group_name: 'Group 1',
      assigned_mgr: 'manager1',
      created_by: 'Admin',
      teams: ['user1', 'user2'],
      elements: [1, 2],
    };

    const existingGroup = { GROUP_ID: 1 }; // Simulate that the group already exists

    // Spy on the repository methods and simulate database behavior
    const createQueryBuilderSpy = jest.spyOn(queryRunner.manager, 'createQueryBuilder');
    createQueryBuilderSpy
      .mockReturnValueOnce({
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getOne: jest.fn().mockResolvedValue(existingGroup),
      });

    // Act & Assert
    await expect(service.create(createSwitchDirectiveDto)).rejects.toThrowError(new HttpException({
      message: 'Group name already exists',
      status: HttpStatus.BAD_REQUEST,
    }, HttpStatus.BAD_REQUEST));

    // Ensure that rollback and release are called in case of error
    expect(queryRunner.rollbackTransaction).toHaveBeenCalled();
    expect(queryRunner.release).toHaveBeenCalled();
  });
