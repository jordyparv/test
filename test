 async update(
    groupId: number,
    updateSwitchDirectiveDto: UpdateSwitchDirectiveDto,
  ) {
    const queryRunner =
      this.DirectiveGroupEntityRepository.manager.connection.createQueryRunner();
    await queryRunner.startTransaction();

    try {
      // Check if the group exists
      const existingGroup = await queryRunner.manager
        .createQueryBuilder()
        .select('g.GROUP_ID')
        .from(DirectiveGroupEntity, 'g')
        .where('g.GROUP_ID = :groupId', { groupId })
        .getOne();

      if (!existingGroup) {
        throw new HttpException(
          {
            message: 'Group not found',
            status: HttpStatus.NOT_FOUND,
          },
          HttpStatus.NOT_FOUND,
        );
      }

      // Update the DirectiveGroupEntity
      await queryRunner.manager
        .createQueryBuilder()
        .update(DirectiveGroupEntity)
        .set({
          GROUP_NAME:
            updateSwitchDirectiveDto.group_name || existingGroup.GROUP_NAME,
          META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
        })
        .where('GROUP_ID = :groupId', { groupId })
        .execute();

      // Update the DirectiveUserGroupMappingEntity
      if (updateSwitchDirectiveDto.assigned_mgr) {
        await queryRunner.manager
          .createQueryBuilder()
          .update(DirectiveUserGroupMappingEntity)
          .set({
            USER_ID: updateSwitchDirectiveDto.assigned_mgr,
            META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
            META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            ASSIGNED_TEAM: updateSwitchDirectiveDto.teams
              ? updateSwitchDirectiveDto.teams.join(',')
              : '',
          })
          .where('GROUP_ID = :groupId', { groupId })
          .execute();
      }

      if (updateSwitchDirectiveDto.teams) {
        await queryRunner.manager
          .createQueryBuilder()
          .update(DirectiveUserGroupMappingEntity)
          .set({
            META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
            META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            ASSIGNED_TEAM: updateSwitchDirectiveDto.teams
              ? updateSwitchDirectiveDto.teams.join(',')
              : '',
          })
          .where('GROUP_ID = :groupId', { groupId })
          .execute();
      }

      // Handle updating elements (either update or remove old elements)
      if (updateSwitchDirectiveDto.elements?.length) {
        // Delete existing elements for the group
        await queryRunner.manager
          .createQueryBuilder()
          .delete()
          .from(DirectiveElementGroupMappingEntity)
          .where('GROUP_ID = :groupId', { groupId })
          .execute();

        // Insert updated elements
        const elementsToInsert = await Promise.all(
          updateSwitchDirectiveDto.elements.map(async (ELEMENT_ID) => {
            const elementMappingIdQuery = await queryRunner.manager.query(
              'SELECT DIRECTIVE_ELEMENT_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
            );
            const elementMappingId = elementMappingIdQuery[0]?.NEXTVAL;

            return {
              ELEMENT_MAPPING_ID: elementMappingId,
              GROUP_ID: groupId,
              ELEMENT_ID,
              META_CREATED_BY: updateSwitchDirectiveDto.updated_by,
              META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
              META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
              META_LAST_UPDATED_DATE: () =>
                'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            };
          }),
        );

        await queryRunner.manager
          .createQueryBuilder()
          .insert()
          .into(DirectiveElementGroupMappingEntity)
          .values(elementsToInsert)
          .execute();
      }

      await queryRunner.commitTransaction();

      return {
        message: 'Switch directive updated successfully',
        status: HttpStatus.OK,
      };
    } catch (error) {
      await queryRunner.rollbackTransaction();
      logger.error(`Unable to update switch directive => ${error.message}`);

      throw new HttpException(
        { message: error.message },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    } finally {
      await queryRunner.release();
    }
  }




import { Test, TestingModule } from '@nestjs/testing';
import { SwitchDirectiveService } from './switch.directive.service';
import {
  HttpException,
  HttpStatus,
  InternalServerErrorException,
} from '@nestjs/common';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { DirectiveUserGroupMappingEntity } from './entities/switch.directive.entity.DirectiveUserGroupMappingEntity';
import { DirectiveGroupEntity } from './entities/switch.directive.entity.DirectiveGroupEntity';
import { DirectiveElementGroupMappingEntity } from './entities/switch.directive.entity.DirectiveElementGroupMappingEntity';
import { SecContactEntity } from './entities/switch.directive.entity.SecContactEntity';
import { SwitchElementEntity } from './entities/switch.directive.entity.SwitchElementEntity';
import { SecUsersEntity } from './entities/switch.directive.entity.SecUsersEntity';
import { CreateSwitchDirectiveDto } from './dto/create.SwitchDirective.dto';
import { SecRolesEntity } from './entities/switch.directive.entity.SecRolesEntity';
import { createMock } from '@golevelup/ts-jest';
import { UpdateSwitchDirectiveDto } from './dto/update.SwitchDirective.dto';

describe('SwitchDirectiveService', () => {
  let service: SwitchDirectiveService;
  let directiveUserGroupMappingRepo: Repository<DirectiveUserGroupMappingEntity>;
  let directiveGroupRepo: jest.Mocked<Repository<DirectiveGroupEntity>>;
  let directiveElementGroupMappingRepo: Repository<DirectiveElementGroupMappingEntity>;
  let secContactRepo: Repository<SecContactEntity>;
  let secContactRepo2: jest.Mocked<Repository<SecContactEntity>>;
  let switchElementRepo: Repository<SwitchElementEntity>;
  let secUsersRepo: Repository<SecUsersEntity>;
  let queryRunner: any;
  let mockQueryBuilder: any;
  let mockQueryRunner: any;
  let mockQueryRunner2: any;
  beforeEach(async () => {
    // Mock QueryRunner
    mockQueryRunner = {
      manager: {
        createQueryBuilder: jest.fn(),
        query: jest.fn(),
      },
      createQueryBuilder: jest.fn(),
      startTransaction: jest.fn(),
      commitTransaction: jest.fn(),
      rollbackTransaction: jest.fn(),
      release: jest.fn(),
    };

    queryRunner = {
      connect: jest.fn(),
      startTransaction: jest.fn(),
      commitTransaction: jest.fn(),
      rollbackTransaction: jest.fn(),
      release: jest.fn(),
      manager: {
        createQueryBuilder: jest.fn().mockReturnValue(queryRunner),
        create: jest.fn(),
        save: jest.fn(),
        insert: jest.fn(),
        getOne: jest.fn(),
      },
    };

    // Mock Repository
    directiveGroupRepo = {
      manager: {
        connection: { createQueryRunner: jest.fn(() => mockQueryRunner) },
      },
      createQueryBuilder: jest.fn(() => mockQueryRunner),
    } as unknown as jest.Mocked<Repository<DirectiveGroupEntity>>;

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SwitchDirectiveService,
        {
          provide: getRepositoryToken(DirectiveUserGroupMappingEntity),
          useValue: createMock<Repository<DirectiveUserGroupMappingEntity>>(),
        },
        {
          provide: getRepositoryToken(DirectiveGroupEntity),
          // useValue: createMock<Repository<DirectiveGroupEntity>>(),
          useValue: directiveGroupRepo,
          // useValue: mockRepository,
        },

        {
          provide: getRepositoryToken(DirectiveElementGroupMappingEntity),
          useValue:
            createMock<Repository<DirectiveElementGroupMappingEntity>>(),
        },
        {
          provide: getRepositoryToken(SecContactEntity),
          // useClass: Repository,
          useValue: createMock<Repository<SecContactEntity>>(),
        },

        {
          provide: getRepositoryToken(SwitchElementEntity),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(SecUsersEntity),
          useClass: Repository,
        },
      ],
    }).compile();

    service = module.get<SwitchDirectiveService>(SwitchDirectiveService);
    directiveUserGroupMappingRepo = module.get<
      Repository<DirectiveUserGroupMappingEntity>
    >(getRepositoryToken(DirectiveUserGroupMappingEntity));
    // directiveGroupRepo = module.get<Repository<DirectiveGroupEntity>>(
    //   getRepositoryToken(DirectiveGroupEntity),
    // );
    directiveElementGroupMappingRepo = module.get<
      Repository<DirectiveElementGroupMappingEntity>
    >(getRepositoryToken(DirectiveElementGroupMappingEntity));
    secContactRepo = module.get<Repository<SecContactEntity>>(
      getRepositoryToken(SecContactEntity),
    );
    switchElementRepo = module.get<Repository<SwitchElementEntity>>(
      getRepositoryToken(SwitchElementEntity),
    );
    secUsersRepo = module.get<Repository<SecUsersEntity>>(
      getRepositoryToken(SecUsersEntity),
    );
    jest
      .spyOn(
        service['DirectiveGroupEntityRepository'].manager.connection,
        'createQueryRunner',
      )
      .mockReturnValue(mockQueryRunner);

    jest.clearAllMocks();
  });
  afterEach(() => {
    jest.clearAllMocks();
  });




 
  describe('createSwitchDirective', () => {
    it('should save a new switch directive successfully', async () => {
      // Mock methods
      let mockInsertQueryBuilder = {
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue([{}]),
      };

      mockQueryRunner.manager.createQueryBuilder
        .mockReturnValueOnce({
          select: jest.fn().mockReturnThis(),
          from: jest.fn().mockReturnThis(),
          where: jest.fn().mockReturnThis(),
          getOne: jest.fn().mockResolvedValue(null),
        })
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder);

      await mockQueryRunner.manager.query
        .mockResolvedValueOnce([{ NEXTVAL: 1 }]) // Group ID sequence
        .mockResolvedValueOnce([{ NEXTVAL: 2 }]) // Mapping ID sequence
        .mockResolvedValue([{ NEXTVAL: 3 }, { NEXTVAL: 5 }, { NEXTVAL: 6 }]); // Element mapping ID sequence

      const createSwitchDirectiveDto = {
        group_name: 'Test Group',
        created_by: 'test_user',
        assigned_mgr: 'manager_user',
        elements: [1, 2, 3],
        teams: ['team1', 'team2'],
      };
      try {
        const result = await service.create(createSwitchDirectiveDto);

        // Assertions
        expect(mockQueryRunner.startTransaction).toHaveBeenCalled();
        expect(mockQueryRunner.commitTransaction).toHaveBeenCalled();
        expect(mockQueryRunner.release).toHaveBeenCalled();
        expect(result).toEqual({
          message: 'Switch directive saved successfully',
          status: HttpStatus.CREATED,
        });
      } catch (error) {
        expect(error).toEqual(
          await mockQueryRunner.manager.createQueryBuilder(),
        );
      }
    });

    it('should throw an error if group name already exists', async () => {
      // Mock existing group
      let mockInsertQueryBuilder = {
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue([{}]),
      };

      mockQueryRunner.manager.createQueryBuilder
        .mockReturnValueOnce({
          select: jest.fn().mockReturnThis(),
          from: jest.fn().mockReturnThis(),
          where: jest.fn().mockReturnThis(),
          getOne: jest.fn().mockResolvedValue({ k: 1 }),
        })
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder);

      const createSwitchDirectiveDto = {
        group_name: 'Existing Group',
        created_by: 'test_user',
        assigned_mgr: 'manager_user',
        elements: [1, 2, 3],
        teams: ['team1', 'team2'],
      };

      try {
        await service.create(createSwitchDirectiveDto);
      } catch (error) {
        expect(error).toEqual(
          new HttpException(
            {
              message: 'Group name already exists',
              status: HttpStatus.BAD_REQUEST,
            },
            HttpStatus.BAD_REQUEST,
          ),
        );
      }

      // Assertions
      expect(mockQueryRunner.startTransaction).toHaveBeenCalled();
      expect(mockQueryRunner.rollbackTransaction).toHaveBeenCalled();
      expect(mockQueryRunner.release).toHaveBeenCalled();
    });

    it('should rollback transaction on error', async () => {
      // Mock query error
      mockQueryRunner.manager.createQueryBuilder.mockImplementationOnce(() => {
        throw new Error('Database error');
      });

      const createSwitchDirectiveDto = {
        group_name: 'Test Group',
        created_by: 'test_user',
        assigned_mgr: 'manager_user',
        elements: [1, 2, 3],
        teams: ['team1', 'team2'],
      };

      await expect(service.create(createSwitchDirectiveDto)).rejects.toThrow(
        new HttpException(
          { message: 'Database error' },
          HttpStatus.INTERNAL_SERVER_ERROR,
        ),
      );

      // Assertions
      expect(mockQueryRunner.startTransaction).toHaveBeenCalled();
      expect(mockQueryRunner.rollbackTransaction).toHaveBeenCalled();
      expect(mockQueryRunner.release).toHaveBeenCalled();
    });
  });
  describe('updateSwitchDirective', () => {
    it('it should update directive ', async () => {
      let updateSwitchDirectiveDto: UpdateSwitchDirectiveDto = {
        group_name: 'test',
        group_id: 12,
        teams: ['test', 'test2'],
        assigned_mgr: 'test',
        elements: [123, 431243, 124],
        updated_by: 'iop',
      };

      let mockInsertQueryBuilder = {
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        update: jest.fn().mockReturnThis(),
        set: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        delete: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue([{}]),
      };

      mockQueryRunner.manager.createQueryBuilder
        .mockReturnValueOnce({
          select: jest.fn().mockReturnThis(),
          from: jest.fn().mockReturnThis(),
          where: jest.fn().mockReturnThis(),
          getOne: jest.fn().mockResolvedValue({ group_name: 'test' }),
        })
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder);

      mockQueryRunner.manager.createQueryBuilder
        .mockReturnValueOnce({
          select: jest.fn().mockReturnThis(),
          from: jest.fn().mockReturnThis(),
          where: jest.fn().mockReturnThis(),
          getOne: jest.fn().mockResolvedValue({ group_name: 'test' }),
        })
        .mockImplementationOnce(() => mockInsertQueryBuilder);

      await mockQueryRunner.manager.query
        .mockResolvedValueOnce([{ NEXTVAL: 1 }]) // Group ID sequence
        .mockResolvedValueOnce([{ NEXTVAL: 2 }]) // Mapping ID sequence
        .mockResolvedValue([{ NEXTVAL: 3 }, { NEXTVAL: 5 }, { NEXTVAL: 6 }]); // Element mapping ID sequence

      try {
        const result = await service.update(12, updateSwitchDirectiveDto);
        expect(result).toEqual({
          message: 'Switch directive updated successfully',
          status: HttpStatus.OK,
        });
      } catch (error) {
        expect(error).toEqual(
          new HttpException(
            {
              message: 'Group not found',
              status: HttpStatus.NOT_FOUND,
            },
            HttpStatus.NOT_FOUND,
          ),
        );
      }
    });
    it('it should return group not exist while update', async () => {
      let updateSwitchDirectiveDto = {
        group_name: 'test',
        group_id: 12,
        teams: ['test', 'test2'],
      };
      let mockInsertQueryBuilder = {
        insert: jest.fn().mockReturnThis(),
        into: jest.fn().mockReturnThis(),
        values: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue([{}]),
      };

      mockQueryRunner.manager.createQueryBuilder
        .mockReturnValueOnce({
          select: jest.fn().mockReturnThis(),
          from: jest.fn().mockReturnThis(),
          where: jest.fn().mockReturnThis(),
          getOne: jest.fn().mockResolvedValue(null),
        })
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder)
        .mockImplementationOnce(() => mockInsertQueryBuilder);
      try {
        await service.update(12, updateSwitchDirectiveDto);
      } catch (error) {
        expect(error).toEqual(
          new HttpException(
            {
              message: 'Group not found',
              status: HttpStatus.NOT_FOUND,
            },
            HttpStatus.NOT_FOUND,
          ),
        );
      }
    });
  });
});
