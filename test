async update(
  updateSwitchDirectiveDto: UpdateSwitchDirectiveDto, 
  groupId: number
) {
  const queryRunner =
    this.DirectiveGroupEntityRepository.manager.connection.createQueryRunner();
  await queryRunner.startTransaction();

  try {
    // Check if the group exists
    const existingGroup = await queryRunner.manager
      .createQueryBuilder()
      .select('g.GROUP_ID')
      .from(DirectiveGroupEntity, 'g')
      .where('g.GROUP_ID = :groupId', { groupId })
      .getOne();

    if (!existingGroup) {
      throw new HttpException(
        {
          message: 'Group not found',
          status: HttpStatus.NOT_FOUND,
        },
        HttpStatus.NOT_FOUND,
      );
    }

    // Update the DirectiveGroupEntity
    await queryRunner.manager
      .createQueryBuilder()
      .update(DirectiveGroupEntity)
      .set({
        GROUP_NAME: updateSwitchDirectiveDto.group_name || existingGroup.GROUP_NAME,
        META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
        META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
      })
      .where('GROUP_ID = :groupId', { groupId })
      .execute();

    // Update the DirectiveUserGroupMappingEntity
    if (updateSwitchDirectiveDto.assigned_mgr) {
      await queryRunner.manager
        .createQueryBuilder()
        .update(DirectiveUserGroupMappingEntity)
        .set({
          USER_ID: updateSwitchDirectiveDto.assigned_mgr,
          META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          ASSIGNED_TEAM: updateSwitchDirectiveDto.teams
            ? updateSwitchDirectiveDto.teams.join(',')
            : '',
        })
        .where('GROUP_ID = :groupId', { groupId })
        .execute();
    }

    // Handle updating elements (either update or remove old elements)
    if (updateSwitchDirectiveDto.elements?.length) {
      // Delete existing elements for the group
      await queryRunner.manager
        .createQueryBuilder()
        .delete()
        .from(DirectiveElementGroupMappingEntity)
        .where('GROUP_ID = :groupId', { groupId })
        .execute();

      // Insert updated elements
      const elementsToInsert = await Promise.all(
        updateSwitchDirectiveDto.elements.map(async (ELEMENT_ID) => {
          const elementMappingIdQuery = await queryRunner.manager.query(
            'SELECT DIRECTIVE_ELEMENT_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
          );
          const elementMappingId = elementMappingIdQuery[0]?.NEXTVAL;

          return {
            ELEMENT_MAPPING_ID: elementMappingId,
            GROUP_ID: groupId,
            ELEMENT_ID,
            META_CREATED_BY: updateSwitchDirectiveDto.updated_by,
            META_LAST_UPDATED_BY: updateSwitchDirectiveDto.updated_by,
            META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            META_LAST_UPDATED_DATE: () =>
              'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          };
        }),
      );

      await queryRunner.manager
        .createQueryBuilder()
        .insert()
        .into(DirectiveElementGroupMappingEntity)
        .values(elementsToInsert)
        .execute();
    }

    await queryRunner.commitTransaction();

    return {
      message: 'Switch directive updated successfully',
      status: HttpStatus.OK,
    };
  } catch (error) {
    await queryRunner.rollbackTransaction();
    logger.error(`Unable to update switch directive => ${error.message}`);

    throw new HttpException(
      { message: error.message },
      HttpStatus.INTERNAL_SERVER_ERROR,
    );
  } finally {
    await queryRunner.release();
  }
}
