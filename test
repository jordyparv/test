jest.spyOn(directiveGroupRepo.manager, 'createQueryBuilder').mockReturnValue({
  // Mock the getOne method to return null (i.e., no existing group)
  getOne: mockGetOne, 

  // Mock the insert method to return itself for method chaining
  insert: jest.fn().mockReturnThis(), 

  // Mock execute to return a success response
  execute: mockExecute
});




import { Test, TestingModule } from '@nestjs/testing';
import { SwitchDirectiveService } from './switch-directive.service';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { DirectiveGroupEntity } from './entities/DirectiveGroupEntity';
import { DirectiveUserGroupMappingEntity } from './entities/DirectiveUserGroupMappingEntity';
import { DirectiveElementGroupMappingEntity } from './entities/DirectiveElementGroupMappingEntity';
import { HttpException, HttpStatus } from '@nestjs/common';
import { createMock } from '@golevelup/ts-jest';

let service: SwitchDirectiveService;
let directiveGroupRepo: Repository<DirectiveGroupEntity>;
let directiveUserGroupMappingRepo: Repository<DirectiveUserGroupMappingEntity>;
let queryRunner: any;
let mockCreateSwitchDirectiveDto: any;

beforeEach(async () => {
  // Create the mock DTO
  mockCreateSwitchDirectiveDto = {
    group_name: 'Test Group',
    created_by: 'admin',
    assigned_mgr: 'manager1',
    teams: ['team1', 'team2'],
    elements: [101, 102, 103],
  };

  // Mock the queryRunner and repository methods
  queryRunner = {
    startTransaction: jest.fn(),
    commitTransaction: jest.fn(),
    rollbackTransaction: jest.fn(),
    release: jest.fn(),
    manager: {
      createQueryBuilder: jest.fn().mockReturnValue({
        getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group found
        insert: jest.fn().mockReturnThis(), // Allow chaining
        execute: jest.fn().mockResolvedValue({ affected: 1, generatedMaps: [] }), // Simulate successful insert with affected rows
      }),
      query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]), // Mock sequence value for group ID
    },
  };

  const module: TestingModule = await Test.createTestingModule({
    providers: [
      SwitchDirectiveService,
      {
        provide: getRepositoryToken(DirectiveGroupEntity),
        useValue: createMock<Repository<DirectiveGroupEntity>>({
          manager: {
            createQueryBuilder: jest.fn().mockReturnValue({
              getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group
            }),
            query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]), // Mock sequence query for group ID
          },
        }),
      },
      {
        provide: getRepositoryToken(DirectiveUserGroupMappingEntity),
        useValue: createMock<Repository<DirectiveUserGroupMappingEntity>>(),
      },
      {
        provide: getRepositoryToken(DirectiveElementGroupMappingEntity),
        useValue: createMock<Repository<DirectiveElementGroupMappingEntity>>(),
      },
    ],
  }).compile();

  service = module.get<SwitchDirectiveService>(SwitchDirectiveService);
  directiveGroupRepo = module.get<Repository<DirectiveGroupEntity>>(getRepositoryToken(DirectiveGroupEntity));
  directiveUserGroupMappingRepo = module.get<Repository<DirectiveUserGroupMappingEntity>>(getRepositoryToken(DirectiveUserGroupMappingEntity));

  // Spying on the methods of queryRunner
  jest.spyOn(queryRunner, 'startTransaction');
  jest.spyOn(queryRunner, 'commitTransaction');
  jest.spyOn(queryRunner, 'rollbackTransaction');
  jest.spyOn(queryRunner, 'release');
  jest.spyOn(queryRunner.manager, 'createQueryBuilder').mockReturnValue({
    getOne: jest.fn().mockResolvedValue(null), // No existing group
    insert: jest.fn().mockReturnThis(), // Chaining insert
    execute: jest.fn().mockResolvedValue({ affected: 1, generatedMaps: [] }), // Simulate successful insert
  });
  jest.spyOn(queryRunner.manager, 'query').mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Mock sequence value
});

it('should successfully create a switch directive', async () => {
  // Mock query results for group, mapping, and element IDs
  queryRunner.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Group ID
  queryRunner.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Mapping ID
  queryRunner.manager.query.mockResolvedValueOnce([{ NEXTVAL: 1 }]); // Element Mapping ID

  // Mock successful insert operation
  directiveGroupRepo.manager.createQueryBuilder().execute.mockResolvedValue({ affected: 1, generatedMaps: [] });

  const result = await service.create(mockCreateSwitchDirectiveDto);

  // Verify that the method returned the expected response
  expect(result.message).toBe('Switch directive saved successfully');
  expect(result.status).toBe(HttpStatus.CREATED);

  // Verify that the transaction methods were called
  expect(queryRunner.startTransaction).toHaveBeenCalled();
  expect(queryRunner.commitTransaction).toHaveBeenCalled();
  expect(queryRunner.release).toHaveBeenCalled();

  // Verify that createQueryBuilder was called correctly
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledTimes(3); // Three calls: one for group, one for mapping, one for elements
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledWith('INSERT INTO DirectiveGroupEntity');
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledWith('INSERT INTO DirectiveUserGroupMappingEntity');
  expect(queryRunner.manager.createQueryBuilder).toHaveBeenCalledWith('INSERT INTO DirectiveElementGroupMappingEntity');
});

it('should throw an error when group name already exists', async () => {
  // Mocking an existing group
  queryRunner.manager.createQueryBuilder().getOne.mockResolvedValue({ GROUP_ID: 1 });

  try {
    await service.create(mockCreateSwitchDirectiveDto);
  } catch (error) {
    expect(error).toBeInstanceOf(HttpException);
    expect(error.response.message).toBe('Group name already exists');
    expect(error.response.status).toBe(HttpStatus.BAD_REQUEST);
  }

  // Verify that rollback is called when an error occurs
  expect(queryRunner.rollbackTransaction).toHaveBeenCalled();
});
















useValue: createMock<Repository<DirectiveGroupEntity>>({
          manager: {
            createQueryBuilder: jest.fn().mockReturnValue({
              getOne: jest.fn().mockResolvedValue(null), // Simulate no existing group
              // You can mock other query builder methods as needed
            }),
            query: jest.fn().mockResolvedValueOnce([{ NEXTVAL: 1 }]), // Mock sequence query
            connection: {
              createQueryRunner: jest.fn().mockReturnValue(queryRunner), // Mocking queryRunner
            },
          },
        }),


beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SwitchDirectiveService,
        {
          provide: getRepositoryToken(DirectiveUserGroupMappingEntity),
          useValue: createMock<Repository<DirectiveUserGroupMappingEntity>>(),
        },
        {
          provide: getRepositoryToken(DirectiveGroupEntity),
          useValue: createMock<Repository<DirectiveGroupEntity>>(),
        },
        {
          provide: getRepositoryToken(DirectiveElementGroupMappingEntity),
          useValue:
            createMock<Repository<DirectiveElementGroupMappingEntity>>(),
        },
        {
          provide: getRepositoryToken(SecContactEntity),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(SwitchElementEntity),
          useClass: Repository,
        },
        {
          provide: getRepositoryToken(SecUsersEntity),
          useClass: Repository,
        },
      ],
    }).compile();

    service = module.get<SwitchDirectiveService>(SwitchDirectiveService);
    directiveUserGroupMappingRepo = module.get<
      Repository<DirectiveUserGroupMappingEntity>
    >(getRepositoryToken(DirectiveUserGroupMappingEntity));
    directiveGroupRepo = module.get<Repository<DirectiveGroupEntity>>(
      getRepositoryToken(DirectiveGroupEntity),
    );
    directiveElementGroupMappingRepo = module.get<
      Repository<DirectiveElementGroupMappingEntity>
    >(getRepositoryToken(DirectiveElementGroupMappingEntity));
    secContactRepo = module.get<Repository<SecContactEntity>>(
      getRepositoryToken(SecContactEntity),
    );
    switchElementRepo = module.get<Repository<SwitchElementEntity>>(
      getRepositoryToken(SwitchElementEntity),
    );
    secUsersRepo = module.get<Repository<SecUsersEntity>>(
      getRepositoryToken(SecUsersEntity),
    );
    queryRunner = {
      startTransaction: jest.fn(),
      commitTransaction: jest.fn(),
      rollbackTransaction: jest.fn(),
      release: jest.fn(),
      manager: {
        createQueryBuilder: jest.fn(),
        query: jest.fn(),
        connection: {
          createQueryRunner: jest.fn().mockReturnValue(queryRunner),
        },
      }
    }
  });




async create(createSwitchDirectiveDto: CreateSwitchDirectiveDto) {
    const queryRunner =
      this.DirectiveGroupEntityRepository.manager.connection.createQueryRunner();
    await queryRunner.startTransaction();

    try {
      const existingGroup = await queryRunner.manager
        .createQueryBuilder()
        .select('g.GROUP_ID')
        .from(DirectiveGroupEntity, 'g')
        .where('g.GROUP_NAME = :groupName', {
          groupName: createSwitchDirectiveDto.group_name,
        })
        .getOne();

      if (existingGroup) {
        throw new HttpException(
          {
            message: 'Group name already exists',
            status: HttpStatus.BAD_REQUEST,
          },
          HttpStatus.BAD_REQUEST,
        );
      }

      const groupIdQuery = await queryRunner.manager.query(
        'SELECT DIRECTIVE_GROUP_SEQ.NEXTVAL FROM dual',
      );
      const groupId = groupIdQuery[0]?.NEXTVAL;

      await queryRunner.manager
        .createQueryBuilder()
        .insert()
        .into(DirectiveGroupEntity)
        .values({
          GROUP_NAME: createSwitchDirectiveDto.group_name,
          GROUP_ID: groupId,
          META_CREATED_BY: createSwitchDirectiveDto.created_by,
          META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
          META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
        })
        .execute();

      const mappingIdQuery = await queryRunner.manager.query(
        'SELECT DIRECTIVE_USER_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
      );
      const mappingId = mappingIdQuery[0]?.NEXTVAL;

      await queryRunner.manager
        .createQueryBuilder()
        .insert()
        .into(DirectiveUserGroupMappingEntity)
        .values({
          MAPPING_ID: mappingId,
          USER_ID: createSwitchDirectiveDto.assigned_mgr,
          GROUP_ID: groupId,
          META_CREATED_BY: createSwitchDirectiveDto.created_by,
          META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
          META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          META_LAST_UPDATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
          ASSIGNED_TEAM: createSwitchDirectiveDto.teams
            ? createSwitchDirectiveDto.teams.join(',')
            : '',
        })
        .execute();

      if (createSwitchDirectiveDto.elements?.length) {
        const elementsToInsert = await Promise.all(
          createSwitchDirectiveDto.elements.map(async (ELEMENT_ID) => {
            const elementMappingIdQuery = await queryRunner.manager.query(
              'SELECT DIRECTIVE_ELEMENT_GROUP_MAPPING_SEQ.NEXTVAL FROM dual',
            );
            const elementMappingId = elementMappingIdQuery[0]?.NEXTVAL;

            return {
              ELEMENT_MAPPING_ID: elementMappingId,
              GROUP_ID: groupId,
              ELEMENT_ID,
              META_CREATED_BY: createSwitchDirectiveDto.created_by,
              META_LAST_UPDATED_BY: createSwitchDirectiveDto.created_by,
              META_CREATED_DATE: () => 'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
              META_LAST_UPDATED_DATE: () =>
                'SYS_EXTRACT_UTC(CURRENT_TIMESTAMP)',
            };
          }),
        );

        await queryRunner.manager
          .createQueryBuilder()
          .insert()
          .into(DirectiveElementGroupMappingEntity)
          .values(elementsToInsert)
          .execute();
      }

      await queryRunner.commitTransaction();

      return {
        message: 'Switch directive saved successfully',
        status: HttpStatus.CREATED,
      };
    } catch (error) {
      await queryRunner.rollbackTransaction();
      logger.error(`Unable to add switch directive => ${error.message}`);

      throw new HttpException(
        { message: error.message },
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    } finally {
      await queryRunner.release();
    }
  }
