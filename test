if (process.argv.length === 3 && process.argv[2] === "populate_switch_attachments") {
  let opsDbConfig = dbConUtil.getOPSDbConfig(config.opsTrackerDB);
  
  global.mssqlConn = new MsSqlUtil(opsDbConfig.mssqlConfig);

  global.mssqlConn.connect()
    .then(() => {
      ldSwitchService.populateSwitchAttachments((err) => {
        global.mssqlConn.disconnect();
        if (err) {
          console.error("Error:", err.message);
          process.exit(1);
        } else {
          process.exit(0);
        }
      });
    })
    .catch((error) => {
      console.error("Connection Error:", error.message);
      process.exit(1);
    });
}




loadSwitchService.prototype.populateSwitchAttachments = function (callback) {
  async.waterfall(
    [
      async.constant(queryFactory.getSwitchAttachmentFromOPS("SWITCH_LOCATION")),
      loadSwitchService.prototype.getDataFromOpsTracker,
      // loadSwitchService.prototype.getDummyFiles,
      loadSwitchService.prototype.parseSwitchAttachment,
      loadSwitchService.prototype.upsertINTOSwitchAttachment,
    ],
    function (err) {
      if (err) {
        logger.info("Error:", err);
        return callback(err);
      } else {
        console.log("Switch Attachments Data Populated Successfully!!");
        return callback();
      }
    }
  );
};




loadSwitchService.prototype.parseSwitchAttachment = function (data, callback) {
  if (!data || data.length === 0) {
    return callback(null, []); // Return an empty array if no data is available
  }

  // Helper function to process each item
  const processItem = function (item) {
    return loadSwitchService.prototype.getFileFromOPS({
      ATTACHMENT_NAME: item.file_name,
      SWITCH_UNID: item.source_universalid
    }).then((file) => {
      const file_type = item.file_path?.split(".")?.pop();

      return {
        REFMETAID: item["source_universalid"],
        ATTACHMENT_NAME: item["file_name"],
        ATTACHMENT_SIZE: item["file_size"],
        ATTACHMENT_TYPE: file_type,
        META_UNIVERSALID: item["meta_universalID"],
        CREATED_ON: item["meta_createdDate"] ? moment(item["meta_createdDate"]).format("YYYY-MM-DD HH:mm:ss") : null,
        CREATED_BY: item["meta_createdBy"],
        MODIFIED_ON: item["meta_lastUpdateDate"] ? moment(item["meta_lastUpdateDate"]).format("YYYY-MM-DD HH:mm:ss") : null,
        MODIFIED_BY: item["meta_lastUpdateBy"],
        ATTACHMENT_CATEGORY: item["source_class"]?.replace(/c2/gi, ""),
        DESCRIPTION: item["description"],
        ATTACHMENT: file
      };
    }).catch((error) => {
      console.log(`Error processing item ${item.file_name}:`, error);
      return null; // Return null if there's an error for this item
    });
  };

  // Create an array of promises for each item in the data
  const attachmentPromises = data.map(processItem);

  // Wait for all promises to resolve
  Promise.all(attachmentPromises)
    .then((attachmentData) => {
      // Filter out null values
      const validAttachmentData = attachmentData.filter(item => item !== null);

      // Return the result through the callback
      callback(null, validAttachmentData);
    })
    .catch((error) => {
      callback(error);
    });
};


loadSwitchService.prototype.getFileFromOPS = function (fileData) {
  const url = `${config.opstracker.url}/C2Attachments/${fileData.SWITCH_UNID}/${fileData.ATTACHMENT_NAME}`;
  
  return axios({
    url: url,
    method: "GET",
    responseType: "arraybuffer",
    headers: {
      Authorization: `${config.opstracker.authorization}`,
    },
  })
  .then((res) => {
    if (res.data) {
      return btoa(String.fromCharCode(...new Uint8Array(res.data)));
    } else {
      return null;
    }
  })
  .catch((error) => {
    // Log the error and return null to handle it gracefully
    logger.error("Error downloading file: ", error.message);
    return null;
  });
};
