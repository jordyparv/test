
loadSwitchService.prototype.getFileFromOPS = async function (fileData) {
  const url = `${config.opstracker.url}/C2Attachments/${fileData.SWITCH_UNID}/${fileData.ATTACHMENT_NAME}`;
  // For testing
  // const url = 'http://txslpmtkpa5v.nss.vzwnet.com/C2Attachments/714B17DCE687DA886214CE44C6D09AB3/test.txt'

  const file = await axios({
    url: url,
    method: "GET",
    responseType: "arraybuffer",
    headers: {
      Authorization: `${config.opstracker.authorization}`,
    },
  })
    .then((res) => {
      if (res.data !== undefined) {
        return btoa(String.fromCharCode(...new Uint8Array(res.data)));
      } else {
        return null;
      }
    })
    .catch((error) => {
      logger.error("Error downloading file: ", error.message);
      throw `Error downloading file: ${error.message}`;
    });

  return file;
};



loadSwitchService.prototype.parseSwitchAttachment = function (data, callback) {
  if (!data || data.length === 0) {
    return callback(null, []); // Return an empty array if no data is available
  }

  // Helper function to process each item
  const processItem = function (item) {
    return loadSwitchService.prototype.getFileFromOPS({
      ATTACHMENT_NAME: item.file_name,
      SWITCH_UNID: item.source_universalid
    }).then((file) => {
      const file_type = item.file_path?.split(".")?.pop();

      return {
        REFMETAID: item["source_universalid"],
        ATTACHMENT_NAME: item["file_name"],
        ATTACHMENT_SIZE: item["file_size"],
        ATTACHMENT_TYPE: file_type,
        META_UNIVERSALID: item["meta_universalID"],
        CREATED_ON: item["meta_createdDate"] ? moment(item["meta_createdDate"]).format("YYYY-MM-DD HH:mm:ss") : null,
        CREATED_BY: item["meta_createdBy"],
        MODIFIED_ON: item["meta_lastUpdateDate"] ? moment(item["meta_lastUpdateDate"]).format("YYYY-MM-DD HH:mm:ss") : null,
        MODIFIED_BY: item["meta_lastUpdateBy"],
        ATTACHMENT_CATEGORY: item["source_class"]?.replace(/c2/gi, ""),
        DESCRIPTION: item["description"],
        ATTACHMENT: file
      };
    }).catch((error) => {
      console.log(`Error processing item ${item.file_name}:`, error);
      return null; // Return null if there's an error for this item
    });
  };

  // Create an array of promises for each item in the data
  const attachmentPromises = data.map(processItem);

  // Wait for all promises to resolve
  Promise.all(attachmentPromises)
    .then((attachmentData) => {
      // Filter out null values
      const validAttachmentData = attachmentData.filter(item => item !== null);

      // Return the result through the callback
      callback(null, validAttachmentData);
    })
    .catch((error) => {
      callback(error);
    });
};

loadSwitchService.prototype.populateSwitchAttachments = function (callback) {
  async.waterfall(
    [
      async.constant(
        queryFactory.getSwitchAttachmentFromOPS("SWITCH_LOCATION")
      ),
      loadSwitchService.prototype.getDataFromOpsTracker,
      // loadSwitchService.prototype.getDummyFiles,
      loadSwitchService.prototype.parseSwitchAttachment,
      loadSwitchService.prototype.upsertINTOSwitchAttachment,
    ],
    function (err) {
      if (err) {
        logger.info("error=>", err);
        return callback(err);
      } else {
        console.log("Switch Attachments Data Populated Successfully!!");
        return callback();
      }
    }
  );
};

if (
        process.argv.length == 3 &&
        process.argv[2] == "populate_switch_attachments"
      ) {
        let opsDbConfig = dbConUtil.getOPSDbConfig(config.opsTrackerDB)
        global.mssqlConn = await new MsSqlUtil(opsDbConfig.mssqlConfig);

        // global.mssqlConn = true;

        if (mssqlConn) {
          try {
            ldSwitchService.populateSwitchAttachments(() => {
              mssqlConn.disconnect();
              process.exit();
            });
          } catch (error) {
            console.error(error.message);
            process.exit();
          }
        }
      } 
