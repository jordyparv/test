const queryFactory = require("../../dao/QueryFactory");
const moment = require("moment");

async function getDummyData() {
  const data = require("../../vnd.json");
  return data.slice(0, 10000);
}

async function getDataFromOpsTracker(query) {
  if (!query) {
    throw new Error("SQL query not found");
  }
  try {
    const result = await mssqlConn.executeQuery(query);
    return result;
  } catch (error) {
    console.error(`Error while executing query: ${query}`, error.message);
    throw error; // Rethrow the error for upstream handling
  }
}

async function parseVendorData(rawData) {
  if (!rawData || rawData.length === 0) {
    console.error("Vendor data not available to parse");
    return [];
  }

  return rawData.map(item => ({
    SOURCE_TYPE: item.SOURCE_TYPE,
    SOURCE_ID: item.SOURCE_ID,
    VENDOR_ID: item.VENDOR_ID,
    PM_CATEGORY: item.PM_CATEGORY,
    META_UNIVERSAL_ID: item.META_UNIVERSALID,
    META_CREATED_DATE: moment(item.META_CREATEDDATE).utc().format("YYYY-MM-DD HH:mm:ss"),
    META_CREATED_BY: item.META_CREATEDBY,
    META_LAST_UPDATED_DATE: moment(item.META_LASTUPDATEDATE).utc().format("YYYY-MM-DD HH:mm:ss"),
    META_LAST_UPDATED_BY: item.META_LASTUPDATEBY,
  }));
}

async function insertDataIntoDB(query, data, batchSize = 10000) {
  if (!query) {
    console.error("Please provide the query to perform on the database");
    return;
  }

  if (!data || data.length === 0) {
    console.error("No data provided for insertion into the database");
    return;
  }

  const errors = [];
  const totalBatches = Math.ceil(data.length / batchSize);

  console.log("Starting to truncate the temporary table...");
  try {
    await oraUtil.execute(queryFactory.getQuery('truncateVendorAssignmentTmp'), {}, (err, result) => {
      if (err) throw err;
      console.log("Temporary table truncated successfully.");
    });
  } catch (error) {
    console.error("Error during table truncation:", error.message);
  }

  console.time("syncVendorAssignmentQuery");
  console.log(`Inserting data in ${totalBatches} batches...`);

  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
    const batch = data.slice(batchIndex * batchSize, (batchIndex + 1) * batchSize);
    const startTime = Date.now(); // Start timing

    try {
      await new Promise((resolve, reject) => {
        oraUtil.batchInsert(query, batch, { useExecuteMany: true }, (err, result) => {
          if (err) {
            reject(err);
          } else {
            const endTime = Date.now(); // End timing
            const duration = ((endTime - startTime) / 1000).toFixed(2); // Duration in seconds
            console.log(`Batch ${batchIndex + 1} of ${totalBatches} inserted successfully in ${duration} seconds.`);
            resolve(result);
          }
        });
      });
    } catch (err) {
      errors.push(err);
    }
  }

  console.timeEnd("syncVendorAssignmentQuery");

  if (errors.length > 0) {
    console.error("Errors occurred while saving data:", errors);
  } else {
    console.log("All batches inserted successfully.");
  }
}

async function populateVendorData(cb) {
  try {
    console.log("Fetching data for vendor population...");
    const opsQuery = queryFactory.getQuery("getVendorAssignment");
    // const rawData = await getDataFromOpsTracker(opsQuery);
    const rawData = await getDummyData();
    const processedData = await parseVendorData(rawData);
    const insertIntoVendorAssignmentTmp = queryFactory.getQuery("insertIntoVendorAssignmentTmp");
    await insertDataIntoDB(insertIntoVendorAssignmentTmp, processedData);
    
    if (cb) cb(null, "Data population successful.");
  } catch (error) {
    console.error("Error during sync:", error);
    if (cb) cb(error);
  }
}

module.exports = { populateVendorData };
