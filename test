MERGE INTO VZW_VENDOR_ASSIGNMENTS target
USING (SELECT :SOURCE_TYPE AS SOURCE_TYPE,
              :SOURCE_ID AS SOURCE_ID,
              :VENDOR_ID AS VENDOR_ID,
              :PM_CATEGORY AS PM_CATEGORY,
              :META_UNIVERSAL_ID AS META_UNIVERSAL_ID,
              :USER_ID AS USER_ID
       FROM dual) source
ON (target.META_UNIVERSAL_ID = source.META_UNIVERSAL_ID)  -- Match based on META_UNIVERSAL_ID
WHEN MATCHED THEN
    UPDATE SET
        target.SOURCE_TYPE = source.SOURCE_TYPE,
        target.SOURCE_ID = source.SOURCE_ID,
        target.VENDOR_ID = source.VENDOR_ID,
        target.PM_CATEGORY = source.PM_CATEGORY,
        target.META_LAST_UPDATED_DATE = SYSDATE,
        target.META_LAST_UPDATED_BY = source.USER_ID
WHEN NOT MATCHED THEN
    INSERT (SOURCE_TYPE, SOURCE_ID, VENDOR_ID, PM_CATEGORY, META_UNIVERSAL_ID, META_CREATED_DATE, META_CREATED_BY, META_LAST_UPDATED_DATE, META_LAST_UPDATED_BY)
    VALUES (source.SOURCE_TYPE, source.SOURCE_ID, source.VENDOR_ID, source.PM_CATEGORY, source.META_UNIVERSAL_ID, SYSDATE, source.USER_ID, SYSDATE, source.USER_ID);


async setSwitchPmVendorAssignment(req: Request, res: Response) {
  try {
    const { switchUnid } = req.params;
    let switchData = null;

    switchUnid = CommonUtil.sanitizeString(switchUnid);
    switchData = await this.switchRepo.checkSwitchUnidInTable(switchUnid);

    if (CommonUtil.isEmpty(switchData)) {
      return res.status(HttpStatus.NOT_FOUND).json(ApiResponseObject(
        HttpStatus.NOT_FOUND,
        "Switch unid does not exist!"
      ));
    }

    const queryParamsArray = req.body as SwitchPmVendorAssignmentType[];

    if (!Array.isArray(queryParamsArray) || queryParamsArray.length === 0) {
      return res.status(HttpStatus.BAD_REQUEST).json(ApiResponseObject(
        HttpStatus.BAD_REQUEST,
        "Payload not found in the request body!"
      ));
    }

    const responses = [];

    for (const queryParams of queryParamsArray) {
      let payload = {
        SOURCE_TYPE: 2,
        META_UNIVERSAL_ID: queryParams.vzw_vendor_assignment_id ?
                           queryParams.vzw_vendor_assignment_id :
                           CommonUtil.generateMetaUniversalId()
      };

      for (const key in constants.ValidSwitchPMVendorAssignmentKeys) {
        if (!CommonUtil.isEmpty(queryParams[key])) {
          payload[constants.ValidSwitchPMVendorAssignmentKeys[key]] =
            typeof queryParams[key] === "string"
              ? CommonUtil.sanitizeString(queryParams[key])
              : queryParams[key];
        } else if (queryParams[key] === '') {
          payload[constants.ValidSwitchPMVendorAssignmentKeys[key]] = null;
        }
      }

      if (Object.values(payload).length !== 6) {
        return res.status(HttpStatus.BAD_REQUEST).json(ApiResponseObject(
          HttpStatus.BAD_REQUEST,
          "Please provide all required fields in the request body!"
        ));
      }

      const data = await this.switchRepo.setSwitchPmVendorAssignment(payload);
      if (data.rowsAffected === 0) {
        throw new Error("Something went wrong! Unable to add the association");
      }

      responses.push('Switch pm vendor assignment added/updated successfully!');
    }

    return res.status(HttpStatus.OK).json(ApiResponseObject(
      HttpStatus.OK,
      responses
    ));
  } catch (error) {
    this.logger.error(error.message);
    return res.status(HttpStatus.INTERNAL_SERVER_ERROR).json(
      ApiResponseObject(HttpStatus.INTERNAL_SERVER_ERROR, "Something went wrong! Try again later.")
    );
  }
}
