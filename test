
  async getSwitchDetailForTypeAhead(req: Request, res: Response) {
    try {
      if (Object.values(req.query).length == 0) {
        return res.status(HttpStatus.BAD_REQUEST).json({
          statusCode: HttpStatus.BAD_REQUEST,
          message: "Please provide the filters.",
        });
      }

      let { main_switch_name, remedy_switch, remedy_callout } = req.query as SwitchDetailForTypeAheadType;

      let filterObj: filterObjType = {};

      if (!CommonUtil.isEmptyString(main_switch_name)) {
        filterObj.key = "main_switch";
        filterObj.value = encloseWildChar(CommonUtil.sanitizeString(main_switch_name));
      } else if (!CommonUtil.isEmptyString(remedy_switch)) {
        filterObj.key = "remedy_switch";
        filterObj.value = encloseWildChar(CommonUtil.sanitizeString(remedy_switch));
      } else if (!CommonUtil.isEmptyString(remedy_callout)) {
        filterObj.key = "remedy_callout";
        filterObj.value = encloseWildChar(CommonUtil.sanitizeString(remedy_callout));
      } else {

        return res.status(HttpStatus.OK).json({
          statusCode: HttpStatus.OK,
          data: [],
        });
        
      }

      const data = await this.switchRepo.getSwitchDetailForTypeAhead(filterObj);

      if (CommonUtil.isEmpty(data)) {
        return res.status(HttpStatus.OK).json({
          statusCode: HttpStatus.OK,
          message: "Data fetched successfully!",
          data: [],
        });
      }

      return res.status(HttpStatus.OK).json({
        statusCode: HttpStatus.OK,
        message: "Data fetched successfully!",
        data,
      });

    } catch (error) {
      this.logger.error(error.message);
      return res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
        statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
        message: "Something went wrong! try again later.",
      });
    }
  }

create one for above one like privous and use service instead of controller
